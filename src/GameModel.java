import java.util.Random;
import java.util.ArrayList;

/**
 * The game model handles the logic of the game (generating the numbers, etc.).
 * The instance of the model is used by the view-controller module
 * to trigger actions (for example, generate a new game) and retrieve information
 * about the current status of the game (the digits, the goal, etc.). The main method
 * in this class is for unit tests only. This class creates a private ArrayList of type
 * integer containing the numbers generated by the number generator. This class creates 
 * a random object of Random type to select random numbers.
 * Methods:
 * getRandom(int min, int max), pick a number between min and max inclusively
 * generateGameTraining(), generates a game with random numbers between 1 and 99 inclusively and
 * puts it in numberList
 * getDigits(), returns a string containing the numbers in numberList
 * createCases(), creates objects of type Case and puts it in an ArrayList of type Case
 * setCasesDimensions(TilePanel tilePanel, int widthRectangle, int heightRectangle), set the
 * dimensions of the cases that are in the ArrayList Case
 * caseSelection(int positionX, int positionY), the method will return a case's identifier 
 * depending on the mouse position passed by parameters
 * validSelection (int identifiantCase1, int identifiantCase2), determines if two cases 
 * that have been selected is a valid selection
 * createGroups(int caseIdentifiant1, int caseIdentifiant2), the method will create groups
 * modifyGroupsIfNecessary(Case case1, Case case2), modify the groups when necessary
 * getGoal(), method used to calculate and getting the goal of the game
 * getAndSetSomme(),method used to calculate and getting the current sum
 * reinitializeSum(), used to set the somme attribut to 0
 * checkIfGoalObtained(), when called, it checks if the goal has been obtained
 * checkIfAllCasesSelected(), when called, it checks if all the cases have been selected
 * sommeBiggerThanGoal(), when called, it checks if the player has surpassed the goal
 * blockSum(), it blocks the modification of the sum
 * unlockSum(), it unlocks the modification of the sum
 * getSumBlockedState(), getter for sumBlocked state
 * getNumberList(), this method will return the numberList
 * getCases(), this method will return the list of cases
 * incrementResets(), increment the resets attribute
 * reinitializeResets(), resets will be 0
 * getReset(), getter for resets 
 * incrementLevel(), it will increment the level
 * getLevel(), getter for the level attribute
 * reininitializeLevel(), this will reinitialize the level to the first level
 * main(String[]), the main in this class is used for unit tests only
 * 
 * @author Kevin Chénier
 * @version E2018
 */
public class GameModel {
	
	//An ArrayList of type integer that will retain all the numbers generated by generateGame()
	private ArrayList<Integer> numberList = new ArrayList<Integer>();
	
	//An ArrayList of type Case that will retain all the cases generated by createCases()
	private ArrayList<Case> cases = new ArrayList<Case>();
	
	//An object of Random type that is used in getRandom() method to randomly chose a number
	Random random = new Random();
	
	//Class attributes
	private int somme, resets, level=Constants.FIRST_LEVEL;
	private double groupNumber;
	private boolean stateSelection, sumBlocked;
	
	/** This is used to randomly get a number between min and max, passed by parameters
	 * 
	 * @author Kevin Chenier
	 * @param min, the minimal number
	 * @param max, the maximal number
	 * @exception if max is lesser than min, then
	 * 				the parameters are not valid
	 * @return the randomly choosed number between min and max
	 */
	
	private int getRandom(int min, int max) {
		
		if(min>max)
			throw new IllegalArgumentException("Max should be greater than min");
		
		return random.nextInt((max - min) + 1) + min;
	}
	
	/** This method will generate a game by choosing random numbers and
	 * putting them in numberList. The total numbers selected will be 
	 * equal to groupNumber. Each number has a 70% chance to be between
	 * 1 and 9 inclusively, and a 30% chance to be between 10 and 99 inclusively
	 * 
	 * @author Kevin Chenier
	 */
	
	public void generateGameTraining() {
		
		//groupNumber will randomly retain a number between 3 and 6 inclusively
		groupNumber = getRandom(3,6);
		
		//There will be groupNumber numbers in numberList
		for(int i=0; i<groupNumber; i++) {
			
			/*
			* 70% chances that the number will be between 1 and 9 inclusively, 30% chances to be 
			* between 10 and 99 inclusively
			*/			
			if(Math.random()<=0.7) 
				numberList.add(getRandom(1,9));
			else
				numberList.add(getRandom(10,99));
		}
	}
	
	public void generateGameArcade() {
			
			//groupNumber will randomly retain a number between 3 and 6 inclusively
			groupNumber = Math.ceil(3.0+3.0*getLevel()/Constants.FINAL_LEVEL);
			
			//There will be groupNumber numbers in numberList
			for(int i=0; i<groupNumber; i++) {
				
				/*
				* 70% chances that the number will be between 1 and 9 inclusively, 30% chances to be 
				* between 10 and 99 inclusively
				*/			
				if(Math.random()<=(0.7-0.3*getLevel()/Constants.FINAL_LEVEL)) 
					numberList.add(getRandom(1,9));
				else
					numberList.add(getRandom(10,99));
			}
		}
	
	/** This method returns a string containing each digit that are in 
	 * numberList
	 * 
	 * @author Kevin Chenier
	 * @return listCaracters, the string that contains the digits
	 */
	
	public String getDigits() {
		
		String listCaracters= "";
		
		//Gets each numbers that are in numberList and put it in listCaracters variable 
		for(int i=0; i<numberList.size(); i++)
			listCaracters = listCaracters + numberList.get(i);
		
		return listCaracters;
	}
	
	/** This method creates objects of type Case and puts them in the arraylist cases
	 * each case contains only one digit, each cases is set to false for their state of 
	 * selection, each cases contains an identifier.
	 * 
	 * @author Kevin Chenier
	 */
	
	public void createCases() {
	
		for(int i=0; i<getDigits().length(); i++)
			cases.add(new Case(Integer.parseInt(this.getDigits().substring(i, i+1)), this.stateSelection, i));
	}
	
	/** This method creates objects of type Case and puts them in the arraylist cases
	 * each case contains only one digit, each cases is set to false for their state of 
	 * selection, each cases contains an identifier.
	 * 
	 * @author Kevin Chenier
	 */
	
	public void setCasesDimensions(TilePanel tilePanel, int widthRectangle, int heightRectangle) {
			
		//Mathematically, the cases dimensions are set to be dynamic with window size
		for(int i=0; i<this.getDigits().length(); i++) {
			cases.get(i).setX0(i*widthRectangle);
			cases.get(i).setY0(0);
			cases.get(i).setX1(widthRectangle+i*widthRectangle);
			cases.get(i).setY1(heightRectangle);
		}
	}
	
	/** This method returns the identifier of a case that has been selected depending on
	 * a x position and a y position
	 * 
	 * @param positionX, the x position
	 * @param positionY, the y position
	 * @return identifiant, the identifier of a specific case
	 */
	
	public int caseSelection (int positionX, int positionY) {
		
		//The attribut that will retain the identifier
		int identifiant = 0;
		
		/*
		 * This for loop determines if positionX and positionY is the dimensions
		 * of a case by passing through all cases
		 */
		
		for(int i=0; i<getDigits().length(); i++) {
	
			if(positionX > cases.get(i).getX0() && 
			positionX < cases.get(i).getX1() &&
			positionY > cases.get(i).getY0() && 
			positionY < cases.get(i).getY1()) {
	
				identifiant =cases.get(i).getIdentifiant();
				break;
				
			} else
				identifiant = -1;
		} 
		
		return identifiant;
	
	}
	
	/** This method compares two cases identifier and determines if the player
	 * made a valid selection when pressing and releasing the mouse
	 * 
	 * @author Kevin Chenier
	 * @return true or false, it returns true if selection is valid, false if not valid
	 */
	
	public boolean validSelection (int identifiantCase1, int identifiantCase2) {
		
		/*
		 * The selection is valid if cases identifiers difference is equal to 1
		 * or if it is the same case that was selected when pressing and releasing the mouse.
		 * The identifiers have to not be -1 too.
		 */
		if(
		(identifiantCase1+1 == identifiantCase2 
		|| identifiantCase1-1 == identifiantCase2 
		|| identifiantCase1 == identifiantCase2)
		&&
		(identifiantCase1!=-1 
		&& identifiantCase2!=-1)
		) 
			return true;
		else
			return false;
	}
	
	/** This method will create a group when two cases were selected
	 * and they were intended by the player to be a group.
	 * 
	 * @param caseIdentifiant1, the first case's identifier that has been selected
	 * @param caseIdentifiant2, the second case's identifier that has been selected
	 * @author Kevin Chenier
	 * @return true or false, it returns true if selection is valid, false if not valid
	 */
	
	public void createGroup(int caseIdentifiant1, int caseIdentifiant2) {
		/*
		 * If the mouse was not pressed or released on a case, we then tell the player
		 * that he has to release or press it on a case. It will catch ArrayOutOfBoundException
		 * because if a case identifier is not valid, it will return -1, Case.cases.get(-1) doesn't exist.
		 */
		try {
		
			/*
			 * These attributes will hold the cases that have been selected
			 */
			Case case1 = getCases().get(caseIdentifiant1);
			Case case2 = getCases().get(caseIdentifiant2);
			
			/*
			 * If the two cases that were selected is a valid selection and they were not previously
			 * selected, we will set their states to true
			 */
			if((validSelection(caseIdentifiant1, caseIdentifiant2) == true )){
				
				//The cases that have been selected will now have a state that is true
				case1.setState(true);
				case2.setState(true);
				
				//Call to the method that will create a group accordingly 
				modifyGroupsIfNecessary(case1,case2);
				
				//If case1 is not the same as case2 this means that they now form a group
				if(!(case1.equals(case2))) {	
					
					case1.setIsInGroup(true);
					case2.setIsInGroup(true);
					case1.setIsInGroupWith(case2);
					case2.setIsInGroupWith(case1);
				}
			}
		
		} catch (Exception ArrayIndexOutOfBoundsException) {
			System.err.println("Vous devez sélectionner les cases et non en dehors de ceux-ci");
		}
	}
	/** This method will modify the group when the player has made
	 * a decision that needs the game model to modify the groups
	 * 
	 * @author Kevin Chenier
	 * @param case1, the first case that has been selected
	 * @param case2, the second case that has been selected
	 */
	private void modifyGroupsIfNecessary(Case case1, Case case2) {
			
		if(case1.isInGroup()==true && case2.isInGroup()==false) {
			//We remove the case (from the group) that is in a group with case1
			case1.getIsInGroupWith().setIsInGroup(false);
			//The case1 has lost its case that it was in a group with, so case1 is no longer in a group
			case1.setIsInGroup(false);
		}
		else if(case2.isInGroup()==true && case1.isInGroup()== false) {
			//We remove the case (from the group) that is in a group with case2
			case2.getIsInGroupWith().setIsInGroup(false);
			//The case2 has lost its case that it was in a group with, so case1 is no longer in a group
			case1.setIsInGroup(false);
		}
		else if(case1.isInGroup()==true && case2.isInGroup()==true && case1.getIsInGroupWith()!=case2) {
			//We remove the cases (from their groups) that are in groups with case1 and case2
			case1.getIsInGroupWith().setIsInGroup(false);
			case2.getIsInGroupWith().setIsInGroup(false);
			//The case2 and case 1 have lost their case that they were in a group with, so case1 and case 2 are no longer in a group
			case1.setIsInGroup(false);
			case2.setIsInGroup(false);
		}
	}
	
	/** This method compares two cases identifier and determines if the player
	 * made a valid selection when pressing and releasing the mouse
	 * 
	 * @author Kevin Chenier
	 * @return true or false, it returns true if selection is valid, false if not valid
	 */
	
	public int getGoal() {
		
		int goal = 0;
		
		for(int i=0; i<numberList.size(); i++)
			goal += numberList.get(i);
		return goal;
	}
	
	/** This method calculate the current sum that the player formed at a particular time
	 * 
	 * @author Kevin Chenier
	 */
	
	public void setSomme() {
		
		//Two variables that will retain the cases selected in the for loop
		Case case1;
		Case case2;
		
		//A variable that will retain the new number formed if two cases were valid to be a group
		int newNumber;
		
		//If the sum has been blocked, we can't modify the state of somme
		if(getSumBlockedState()==false) {
			
			reinitializeSomme();
			
			for(int i=0; i<getDigits().length(); i++) {
				
				//We give to variable case1 the value of the object at Case.cases.get(i)
				case1=cases.get(i);
				
				/*
				 * If the first case's state is true(has been selected) and has not yet been calculated in the 
				 * current sum, then we check if the first case is in a group. If it is in a group, then we 
				 * attribute to case2 the case that is in a group with case1. We then form a new number with these 
				 * two cases and add it to the current sum. If the first case is NOT in a group
				 * then we only get its number with the method getNumber() and add it to the current sum
				 */
				if (case1.getState()==true) {
					if(case1.isInGroup()==true) {
						case2 = case1.getIsInGroupWith();
						
						/*
						 * We select the two strings that represent the number that is in the two cases, then we
						 * put them into a string that will be transformed into a int number with the function
						 * Integer.parseInt.
						 */
						newNumber=Integer.parseInt(case1.toString()+case2.toString());
						
						somme+=newNumber;
						
						/*
						 * We skip an iteration because we are no longer interested with the case that was in a
						 * group with Case.cases.get(i)
						 */
						i++;
					} else {
						somme+=case1.getNumber();
					}
				}
			}	
		}
	}
	
	/** This method will return the value of somme
	 * 
	 * @return somme, the current sum
	 * @author KevinChénier
	 */
	
	public int getSomme() {
		return this.somme;
	}
	
	/** This method is used to reinitialize the current sum to 0 when it is necessary to
	 * do so. This method also logically set all the cases attribute didCalculateSum to false.
	 * 
	 * @author KevinChénier
	 */
	public void reinitializeSomme() {
		somme = 0;
	}
	
	/** This method compares the current sum to the goal. If the goal is reached, then
	 * the method returns true.
	 * 
	 * @author Kevin Chenier
	 * @return true or false, it returns true the goal has been achieved, or false if it
	 * has not been achieved
	 */
	
	public boolean checkIfGoalObtained() {
		if(somme==getGoal()) 
			return true;
		else
			return false;
	}
	
	/** This method checks if all the cases have been selected.
	 * 
	 * @author Kevin Chenier
	 * @return verdict, it will be true if all the cases have been selected
	 */
	
	public boolean checkIfAllCasesSelected() {

		//case1 will retain Case.cases.get(i) in for loop
		Case case1;
		
		//Verdict will retain the information about the result
		boolean verdict = false;
		
		int i = 0;
	
		/*
		 * If all cases are selected, then the verdict will remain true, else
		 * the verdict will be false and break the loop that goes until all cases
		 * were checked.
		 */
		
		while(i<getDigits().length()) {
			case1=cases.get(i);
			
			if(case1.getState()==true)
				verdict = true;
			else {
				verdict = false;
				break;
			}
			i++;
		}
		return verdict;
	}
	
	/** This method will check if the current sum is bigger than goal
	 * 
	 * @author Kevin Chenier
	 * @return true or false, it returns true if the sum is bigger than goal
	 */
	
	public boolean sommeBiggerThanGoal() {
		if(somme>getGoal())
			return true;
		return false;
	}
	
	/** This method will block the state of the current sum
	 * 
	 * @author Kevin Chenier
	 * @return true if goal obtained, or all cases selected, or somme > goal
	 */
	
	public void blockSum() {
		sumBlocked=true;
	}
	
	/** This method will unlock the state of the current sum
	 * 
	 * @author Kevin Chenier
	 */
	
	public void unlockSum() {
		sumBlocked=false;
	}
	
	/** This method will return the state of the attribute
	 * sumBlocked
	 * 
	 * @return sumBlocked
	 * @author Kevin Chenier
	 *
	 */
	
	public boolean getSumBlockedState() {
		return this.sumBlocked;
	}

	
	/**This method will return the list containing the numbers
	 *
	 * @return numberList, the list of numbers
	 * @author Kevin Chenier
	 */
	
	public ArrayList<Integer> getNumberList() {
		return this.numberList;
	}
	
	/**This method will return the list containing the cases
	 *
	 * @return cases, the list of cases
	 * @author Kevin Chenier
	 */
	
	public ArrayList<Case> getCases() {
		return this.cases;
	}
	
	/** resets attribute will increment when the method is called
	 * 
	 * @author Kevin Chenier
	 */
	
	public void incrementResets() {
		resets++;
	}
	
	/** resets attribute will be reinitialized when called
	 * 
	 * @author Kevin Chenier
	 */
	
	public void reinitializeResets() {
		resets=0;
	}
	
	/**This method will return the resets attribute
	 * 
	 * @return resets
	 * @author Kevin Chenier
	 */
	public int getReset() {
		return resets;
	}
	
	/**This method will increment the level in arcade mode
	 * 
	 * @author Kevin Chenier
	 */
	
	public void incrementLevel() {
		level++;
	}
	
	/**This method will return the level in arcade mode
	 * 
	 * @return level, the level the player is in currently
	 */
	public int getLevel() {
		return level;
	}
	
	/**This method will restart the arcade game
	 * 
	 * @return level, the level the player is in currently
	 */
	
	public void reinitializeLevel () {
		level=Constants.FIRST_LEVEL;
	}
	
	/**This method will verify if the max level has been reached
	 * 
	 * @return true, if the max level has been reached
	 * @author Kevin Chenier
	 */
	
	public boolean checkIfLevelMaxReached() {
		if(getLevel()==Constants.FINAL_LEVEL+1)
			return true;
		else
			return false;
	}
	
	/**
	 * UNIT TEST, DECOMMENT TO TEST generateGame() 50 TIMES!
	 */
	
	/*
	public static void main(String[] args) {
		
		GameModel test = new GameModel();
		
		for(int i=0; i<50; i++) {
			test.generateGame();
			System.out.println("Liste" + i +": " + GameModel.numberList);
			System.out.println("Chaîne de caractères contenant les nombres générés: " + test.getDigits());
			GameModel.numberList.clear();
		}
	}
	
	*/
}
